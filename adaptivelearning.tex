\begin{savequote}[.5\linewidth]
  ``All models are wrong; some models are useful.''
  \qauthor{- George Box}
\end{savequote}

\chapter{Adaptive Learning}

Here we talk about adaptive and interpretable methods.

\section{Challenges in Cancer Data}
\subsection{Cancer Heterogeneity}

\subsection{Batch Effects and Noise}

\section{RatBoost}
\subsection{Background}
Over the past few decades, biology has transformed into a high throughput research field, both in terms of the number of different measurement techniques as well as the amount of variables measured by each technique (e.g., from Sanger sequencing to deep sequencing), and is more and more targeted to individual cells~\cite{Shapiro2013}. This has led to an unprecedented growth of biological information. Consequently, techniques that can help researchers find important insights into the data are becoming increasingly important.
Predicting survival of cancer patients based on measurements from
microarray experiments has been a field of great interest, but there
is often very little overlap between the important genes or biomarkers
identified by different studies~\cite{Ein-Dor2005}. Several reasons
have been suggested to explain these findings (e.g., heterogeneity of
cancer samples or insufficient sample size). Attempts have been made
to incorporate additional information from other sources, such as
protein-protein interaction (PPI) networks, to make the predictions
more robust~\cite{Chuang2007}. One of the latest approaches integrates
network and expression data by introducing a network-induced
classification kernel (NICK)~\cite{Lavi2012}. Although this method
exhibits state-of-the-art performance, the way it penalizes genes that
are connected to not-predictive genes can result in selection of
isolated features as important features for prediction. We observed
this bias of the method towards isolated nodes on additional
experiments on synthesized data as shown in Section \ref{sec:NICK}. Another issue is that in PPI networks, genes or proteins, which
have been known to researchers longer and are well-known, are studied
more and therefore have more edges connected to them; whereas less
well-known genes and proteins are in sparser areas of the
network. This bias might further affect the judgment of methods like
NICK that use a PPI networks as an input. Consequently, we rely on the
fact that such networks exist between genes and proteins, but we do
not take them as input. If
there is a dependence between input features, which is the case in
many biological settings, our method can benefit from this
effect. Otherwise, it is reduced to a standard ensemble method.
Furthermore, a central assumption underlying many methods is that all data are drawn from the same unknown underlying distribution. This may not be the case, especially for heterogeneous cancer samples, and in particular not for all measured genes.

In this work, we introduce a method that is aware of this potential bias and utilizes an estimate of the differences during the generation of the final prediction method. For this, we introduce a set of sparse classifiers based on $L1$-SVMs~\cite{bradley1998feature}, where each set of features used by one classifier is disjoint from the selected feature set of any other classifier. Furthermore, for each feature chosen by one of the classifiers, we introduce a regression model that uses additional features and is based on Gaussian process regression. These regression models are then used to estimate how predictable the features of each classifier are for each test sample. This information can then be used to find a confidence weighting of the classifiers, i.e. up-weighting classifiers with high confidence and down-weighting classifiers with lower confidence, for each test sample. Schapire and Singer show that incorporating confidences of classifiers can improve the performance of an ensemble method~\cite{adaboost99improved}. However, in their setting, confidences of classifiers are estimated using the training data and are thus fixed for all test samples, whereas in our setting, we estimate confidences of individual classifiers per given test sample. Another related work includes mixture of experts, in which the model trains a set of neural networks and uses a gating network to set the weights of the networks~\cite{jacobs1991adaptive}. One issue with their method is that neural networks with lower performance will not be optimized as much as networks with better performance on training data since the gate module down-weights the error propagated to them. Also training of the gating network is interconnected with the neural network experts and afftects training of those modules. Our method, in contrast, trains each module independently using all training samples, and their reliability does not affect how they are trained. Bayesian hierarchical mixtures of experts takes a more similar approach, but the method is complex, and it has a high time complexity to train the architecture of the hierarchy~\cite{bishop2002bayesian}.

We show that this method exhibits state-of-the-art performance for different cancer types, with gene expression or methylation data sets as the input. Since the weighting of the classifiers is customized for each test sample, the estimated confidences can offer insights into the specific characteristics of each individual's cancer. To facilitate interpretation of the model, we then create a visualization of the important genes found through this analysis for each test sample. Additionally, we show how the important genes of the training set can be found using our learning method and cross validation.

Our idea might resemble ensemble feature selection, which involves
aggregating multiple feature scores from several scoring
mechanisms. These scoring mechanisms vary from being several different
methods, to being the same method applied to different parts of the data such as a random cross validation scheme~\cite{saeys2008robust}. This idea has been studied further by other researchers and they introduced two different methods to aggregate scores from different models. They use an ensemble of support vector machines which on its own has been used to select features in a given data set in other works~\cite{guyon2002gene}. Although we use an ensemble of support vector machines, our goal is not to give a ranking to features of the data set, rather to find multiple parsimonious gene sets that are predictive of the outcome on their own, and use all of them in parallel to predict the outcome. 

Similar to this approach, in another work, iRDA uses a different approach and can report multiple parsimonious gene sets~\cite{lai2015irda}. One significant difference between iRDA and our work is that we have an embedded prediction approach using these sets, which iRDA lacks. Furthermore, gene sets are somehow ordered in iRDA according to their "strength", and within each set, redundant genes are removed. In our model redundant genes can be included in two different ways. One is within different individual learners. For example, if genes $g_1$ and $g_2$ are both strong but redundant, individual learner 1 might include $g_1$, and individual learner 2 might include $g_2$. Also, if there are more redundant or related genes in the gene pool, they will be used to estimate how reliable $g_1$ and $g_2$ are. Therefore instead of dismissing them, we exploit the fact that they exist. 

Related to sorting genes and testing for significance of a reported gene set, Gene Set Enrichment Analysis (GSEA) and its modifications are a commonly used tool~\cite{shi2007gene, subramanian2005gene}. GSEA based methods rank genes depending on how much they relate to the outcome. The choice of relationship is rather free and can vary from Pearson correlation to mutual information. Then for a given gene set, a p-value is calculated by estimating how often a random gene set appears before the given set on the list. There have been several modifications and improvements to the method~\cite{nam2008gene, dopazo2006functional}. Although it is true that GSEA is used to assess the relevance or importance of a given set to the outcome, we need to remember that a particular gene set might consist of genes that are not necessarily important on their own, but are predictive once considered together. Our method does not consider genes individually whereas GSEA does to sort the genes in the first place. Therefore we believe GSEA based methods are not suitable to assess how well our method performs.

\subsubsection{Analysis of NICK}
\label{sec:NICK}
Lavi, et al. modified the standard SVM kernel as shown in Formula \ref{frm:nick1}~\cite{Lavi2012}:

            \begin{align}
              &\min_{\mathbf{w}, w_0}\left\{\frac{1}{2}\|\mathbf{w}\|^2 + \frac{1}{2}\beta\sum_{(j,k)\in E}(w_j-w_k)^2\right\} \nonumber \\
              \text{s.t.:} & \nonumber \\
              &\forall i \in \{1,\cdots,n\} : (\mathbf{w}\mathbf{x}_i+w_0)y_i\geq 1
            \label{frm:nick1}
            \end{align}
          
\noindent Dual Problem:
            \begin{align*}
              &\max_\alpha\left\{\sum_{i=1}^n\alpha_i-\frac{1}{2}\sum_{i=1}^n\sum_{j=1}^n\alpha_i\alpha_j y_i y_j (\mathbf{x}_i^T\mathbf{L})(\mathbf{L}^T\mathbf{x}_j)\right\}\\
              &\mathbf{L}\mathbf{L}^T=(\mathbf{I}+\beta \mathbf{B})^{-1}\\
              \text{s.t.: }&\\
              &\forall i \in \{1,\cdots,n\}: \sum_{i=1}^n\alpha_iy_i=0\\
              &\forall i \in \{1,\cdots,n\}: \alpha_i \geq 0 \\
              &\text{Laplacian matrix:}\\  & \mathbf{B} = \mathbf{D} - \mathbf{A}
            \end{align*}

\noindent Dual to Primal:
            
            $\mathbf{w} = (\mathbf{I} + \beta \mathbf{B})^{-1} \sum_{i = 1}^n \alpha_i y_i \mathbf{x}_i$ \\

\noindent Our approach is summarized as:

        \begin{itemize}
          \item Reverse engineer the learned machine to extract important genes after using the network information.
          \item Solve SVM problem for original and transformed data.
          \item Calculate $\mathbf{w}$ for both models.
          \item Compute for each pair of nodes, for each model: \\
              $Score(i, j) = \frac{|w_i| + |w_j|}{2} \times e^{-max\left(d_G(i, j), 1\right)}$
          \item Report pairs with highest scores for both trained models.
        \end{itemize}

        \begin{figure}[!ht]
          \centering
          \includegraphics[width=.8\textwidth]{figs/nick/synthesized-1slide}
          \label{fig:1}
          \caption{{\color{blue}Blue}: random gene, {\color{orange}Orange}: Signal node being a member of a pathway of signal nodes, {\color{yellow}Yellow}: A lonely signal node}
        \end{figure}

        \noindent Fig. \ref{fig:1} shows an example of our random network. We select values of coresponding genes for nodes as follows:
        \begin{itemize}
        \item Signal nodes (genes):
          $ f(n) = \left\{ 
          \begin{array}{l l}
            N(-\mu, 1) & \quad \text{if $n$ is in class $1$}\\
            N(\mu, 1) & \quad \text{if $n$ is in class $2$}
          \end{array} \right.$
        \item Random nodes (non-informative genes): $f(n) = N(0, 1) $
        \end{itemize}


\subsection{Methods}
\subsubsection{Materials}
\textbf{Data Sources:}
In this article, our method is applied to two different data types: gene expression data and DNA methylation data, which we retrieved from The Cancer Genome Atlas (TCGA)~\cite{tcga-ref}. TCGA is a joint effort of the National Cancer Institute and the National Human Genome Research Institute to advance the understanding of the molecular basis of cancer. They provide access to the different measurements from cancer samples that have been analyzed to external researchers. 
Samples are categorized according to diagnosed cancer from which we use the following groups:

\begin{itemize}
\item \emph{Acute Myeloid Leukemia (LAML)}~\cite{laml2013}: At the time of writing, the data set includes 200 samples. 194 samples contain methylation data and we use the part of the data measured by JHU-USC HumanMethylation450 arrays. 173 samples contain mRNA data measured by HG-U133 arrays. In this article the methylation data is referred to as TCGA-LAML. Among available characteristics of samples, ``risk group'' and ``vital status'' are chosen as target classes. These labels show the aggressiveness of the disease. 
In our analysis, regarding risk group, \{favorable\} and \{intermediate/normal, poor\} samples form our two group, and in the analysis of vital status, \{alive\} and \{dead\} samples form our two groups of samples.

\item \emph{Breast invasive carcinoma (BRCA)}~\cite{brca2012}: This data set includes 993 samples with clinical data, and we use the methylation data component measured by JHU-USC HumanMethylation450 arrays. Only very few samples in this data set are indicated as having metastasized (8 samples).
  Hence the data are analyzed according to ``tumor size'', ``affected nearby lymph nodes'', ``stage'', and ``estrogen receptor''. Estrogen receptor was shown to be an important factor in prognosis~\cite{knight1977estrogen}, and along with other factors directly affects the decision for therapy~\cite{goldhirsch2001meeting,national2001national}. For tumor size \{T1, T2\} samples are one category and \{T3, T4\} the other category; in order to analyze affected nearby lymph nodes, \{N0\} is compared to \{N1, N2, N3\}; stage is analyzed as having \{stage I, stage II\} vs. \{stage III\} samples. Estrogen receptor status of samples is either positive or negative, and they form our two classes.
\end{itemize}

\textbf{Data Preprocessing:}
To prepare gene expression data for analysis, microarray probes are mapped to their respective gene. If there are multiple probes for a gene, the median reported gene expression value of those probes is adopted as the gene expression for that gene.

Preparing the methylation data, we use the nearby gene for each methylation site available for each sample and each methylation site. The median beta value of methylation sites mapped to each gene is taken as the methylation value of the corresponding gene. In this process only methylation sites located on the promoter region of a gene are considered and others are discarded.

\subsubsection{Learning a Mixture of Disjoint Classifiers}
When dealing with cancer, we need to consider the fact that tumors of the same type of cancer can be very different in nature and they are usually classified as different cancer subtypes. In fact, even one single tumor can be very heterogeneous~\cite{heppner1984tumor}. This means that the malignancies causing the cancer to happen are genetically different between subtypes, or even within subtypes, and it is possible to have multiple underlying cellular processes causing a particular cancer.
Also it is important to note that the nature of our given data is such that the input features are properties measured from genes, e.g. gene expression or methylation values, and these variables are correlated and statistically dependent on each other. Our method tries to exploit these properties of the problem to infer an interpretable model with state-of-the-art performance.

\noindent Our method can be characterized by the following key parts:\\

\noindent Training phase:
\begin{itemize}
\item Fit several individual classifiers to the data, in such a way that the features of the data they use are disjoint sets.
\end{itemize}
Prediction phase:
\begin{itemize}
\item Calculate the prediction confidence of each individual classifier by:
\begin{itemize}
\item Estimating the reliability of input features of the classifier;
\item Estimating the confidence of the output based on the decision values.
\end{itemize}
\item Calculate a weighted prediction label based on the individual classifier confidences.
\end{itemize}

\textbf{Properties of the Individual Classifiers:}
A wide variety of classifiers can be used within our framework. One requirement is that the classifier is regularized (i.e., the stronger the regularization, the less complex the model gets and consequently the less features are used). The classifier is also required to report the probability of its calculated output, or to give a decision value according to which it chooses the predicted class. We use an $L1$ regularized SVM for this purpose with a linear kernel~\cite{bradley1998feature}. The $L1$ regularization makes the SVM sparse, i.e. using only a few input features, and the linear kernel allows us to infer which features are used in the decision function of the SVM after it is fit to the data.

\textbf{Training the Individual Classifiers:}
The model starts with no individual classifier and an empty set of excluded features. In each step, the excluded set of features is removed from the data, then a classifier is fit to the data. Next the features used by the most recent trained classifier are added to the excluded set. In the case of a linear kernel SVM, this is achieved by finding features with a non-zero coefficient in the model. This way the features being used by classifiers are disjoint and might represent different underlying causes of groups into which samples are to be classified.

\textbf{Combining Classifiers by Estimating Confidences of Individual Predictors:}
Given a set of classifiers, the question is how to combine them to come up with a joint prediction value for each test sample for which we want to predict the output label. The intuition behind combining the classifiers is to put more weight on classifiers that use features whose behavior is similar to the training data. This is motivated by the fact that some parts of the test data might behave very differently to the training data, meaning that a classifier using these features should have lower performance than a classifier using features that are distributed similarly to the training data. Therefore we need to evaluate the reliability of the input features of each individual classifier. In scenarios like gene expression or methylation analysis, we usually have many input features. Furthermore, many features are correlated and statistically dependent. The idea of our new method is to build separate prediction models for each feature of each classifier. These prediction models can then be used to obtain a confidence for the feature in a given test sample. These confidences can then be combined for each classifier to give a weighting of the classifiers for the given test sample.
To evaluate an observed feature $f$, we try to choose a few statistically dependent features, and fit a model to predict $f$. 
To find these features, first the estimated maximal information coefficient (MIC) of all other features with feature $f$ is calculated~\cite{reshef2011detecting}. Then, features having MIC value within the top $5\%$ or the 5 features with highest MIC with $f$ (if the top $5\%$ features consist of less than 5 features), are selected as predictors of $f$.
Given a test sample, the closer the predicted value of $f$ is to the observed value, the more reliable it is. To quantify this, we need to not only know the predicted value of the feature, but also a confidence interval for that prediction. This can be achieved using Gaussian processes, which give the mean and variance of the posterior probability under the condition of observed values for selected features. A weighted average of these values gives us the overall reliability of the features of an individual classifier. A schematic view of the trained classifier is shown in Fig.~\ref{fig:ratboost-schema}.

\begin{figure}[!ht]
  \centering
  \includegraphics[width=.6\textwidth]{figs/rat/m9}
  \caption{Schematic view of the method}
  \label{fig:ratboost-schema}
\end{figure}

In addition to the confidence in the classifier estimated by looking at the confidences of its individual features, we also account for the confidence that the classifier has in the prediction label of the test sample. If the method supplies such a confidence value (e.g., Gaussian processes), we can directly use it. Otherwise, we estimate it using the decision value. In our setting, the linear SVM gives a decision value whose sign defines the predicted class. Using these values we estimate a confidence for each individual classifier. Several approaches exist for deriving a confidence from the decision values~\cite{Lin2007}. Whether these or other additional methods could lead to further improvements of our method, will be topic of further study.

More formally speaking, define $X$ to be the set of input samples, $X_s$ to be the input vector of sample $s$, $y_s$ and $\hat{y}_s$ to be respectively the original label and predicted output of sample $s$, $\Delta$ to be the set of individual classifiers, $l_i$ to be an individual classifier, $\Phi_{l_i}$ the set of input features of classifier $l_i$, $l_i(X_s)$ to be the label predicted by classifier $l_i$ for sample $X_s$, and $f$ to be a feature, $X_{s,f}$ to be the observed value of feature $f$ in sample $X_s$, $|w_{l_i}(f)|$ to be the absolute value of the weight of feature $f$ in the decision function of classifier $l_i$, and $g_f$ to be the Gaussian process predicting feature $f$ using feature set $\Phi_f$.
Also $\mu_{g_f(X_s)}$ and $\sigma_{g_f(X_s)}$ are the mean and standard deviation of the posterior probability given by Gaussian process $g_f$ under the condition of observing values of features in $\Phi_f$, 
and $\mu_{l_i}$ and $\sigma_{l_i}$ are respectively the expected mean and standard deviation of the decision value of classifier $l_i$. Here $F$ is the cumulative distribution function of a standard normal distribution.

The training phase of the model is shown in Fig.~\ref{fig:train}, in which, $N$ is the number of individual learners to be included in the model, $\Phi_l$ is the union over all $\Phi_{l_i}$ and $X_{-\Phi_l}$ is the input $X$ after discarding all features of the set $\Phi_l$. TOP is the function which selects the maximum of the top $5$ and top $5\%$ features $f'$ of all features ordered by MIC with feature $f$.

\tikzstyle{block} = [rectangle, draw, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{entity} = [rectangle, draw, text centered]
\tikzstyle{line} = [draw, rounded corners, -latex']

\begin{figure}
\centering
\begin{tikzpicture}[node distance = 4em, auto]
  \node [block] (phi_l) {\footnotesize $\Phi_l \leftarrow \{\}$};
  \node [block, below of=phi_l, text width = 7em, node distance = 5em] (i) {\footnotesize $i \leftarrow 0$};
  \node [block, below of=i, text width = 7em] (i_inc) {\footnotesize $i < N$};
  \node [block, below of=i_inc, text width=12em] (fit_li) {\footnotesize $l_i \leftarrow \text{L1-SVM}(X_{-\Phi_l}, y)$};
  \node [block, below of=fit_li, text width=7em] (up_phi) {\footnotesize $\Phi_l \leftarrow \Phi_l \cup \Phi_{l_i}$};
  \path [line] (fit_li) -- (up_phi);
  \node [block, below of=up_phi] (inc_i) {\footnotesize $i \leftarrow i + 1$};
  \path [line] (up_phi) -- (inc_i);

  \node [block, below of=inc_i, node distance = 5em] (f) {\footnotesize $f \in \Phi_{l_i}$};
  \node [block, below of=f, text width = 13em, node distance = 5em] (phi_f) {\footnotesize$\Phi_f \leftarrow \text{TOP}\left\{ \left( f', \text{MI}\left(f,f'\right)\right) \right\} $};
  \node [block, below of=phi_f, text width=10em] (g_f) {\footnotesize $g_f \leftarrow \text{GP}(X_{\Phi_f}, f)$};
  \path [line] (phi_f) -- (g_f);

  \node [block, dashed, fit={($(f.north)+(0,1em)$) (phi_f) (g_f)}] (for2) {};
  \node at (for2.north west) [below right] {for};
  \node [block, dashed, fit={($(i.north)+(0,1em)$) (phi_f) (g_f) (for2) (inc_i)}] (for1) {};
  \node at (for1.north west) [below right] {for};

  \path [draw, dashed] ($(for1.north west)!.13!(for1.south west)$) -- ($(for1.north east)!.13!(for1.south east)$);
  \coordinate (coordinate1) at ($(for1.north west)!.13!(for1.south west)$);
  \node at (coordinate1.east) [below right] {while};
  \path [draw, dashed] ($(for1.north west)!.23!(for1.south west)$) -- ($(for1.north east)!.23!(for1.south east)$);
  \coordinate (coordinate2) at ($(for1.north west)!.23!(for1.south west)$);
  \node at (coordinate2.east) [below right] {do};

  \path [draw, dashed] ($(for2.north west)!.32!(for2.south west)$) -- ($(for2.north east)!.32!(for2.south east)$);
  \coordinate (coordinate3) at ($(for2.north west)!.32!(for2.south west)$);
  \node at (coordinate3.east) [below right] {do};

  \node at ($(for1.north west)!{(1 * 1/2)}!(for1.north east)$) [entity, fill=white] (phi_l_entity) {\footnotesize $\Phi_l$};
  \node at ($(for1.north west)!{(1 * 1/4)}!(for1.north east)$) [entity, fill=white] (X_entity) {\footnotesize $X$};
  \node at ($(for1.north west)!{(3 * 1/4)}!(for1.north east)$) [entity, fill=white] (y_entity) {\footnotesize $y$};
  \path [line] (phi_l) -- (phi_l_entity);

  \node at ($(for2.north west)!{(1 * 1/3)}!(for2.north east)$) [entity, fill=white] (X_entity2) {\footnotesize $X$};
  \node at ($(for2.north west)!{(2 * 1/3)}!(for2.north east)$) [entity, fill=white] (phi_li_entity) {\footnotesize $\Phi_{l_i}$};
\end{tikzpicture}
\caption{UML activity diagram of the training process}
\label{fig:train}
\end{figure}

\noindent Now given a test sample $X_s$, the estimated confidence of a feature $f$ is:

\begin{equation}
c_f(X_s) := 2 \cdot F\left(-\left| \frac{X_{s,f} - \mu_{g_f(X_s)}}{\sigma_{g_f(X_s)}}\right|\right)
\end{equation}

\noindent Then the overall feature reliability or confidence of a classifier $l_i$ is estimated as:

\begin{equation}
c^1_{l_i}(X_s) := \frac{\sum_{f \in \Phi_{l_i}} c_f(X_s) \cdot \left| w_{l_i}(f) \right|}{\sum_{f \in \Phi_{l_i}} \left| w_{l_i}(f) \right|}
\end{equation}

\noindent Also the estimated output confidence of the classifier $l_i$ is:

\begin{equation}
c^2_{l_i}(X_s) := 1 - 2 \cdot F\left(-\left| \frac{l_i(X_s) - \mu_{l_i}}{\sigma_{l_i}}\right|\right)
\end{equation}

\noindent and the final confidence of the classifier $l_i$ is then:

\begin{equation} 
c_{l_i}(X_s) := c^1_{l_i}(X_s) \cdot c^2_{l_i}(X_s)
\end{equation}

\noindent Finally, the predicted class $\hat{y}_s$ is calculated as the sign of a weighted vote among individual classifiers:

\begin{equation}
\hat{y}_s := \textrm{sign}\left(\frac{\sum_{l_i \in \Delta} c_{l_i}(X_s) \cdot l_i(X_s)}{\sum_{l_i \in \Delta} c_{l_i}(X_s)}\right)
\end{equation}

\subsubsection{Visualization of Model Predictions}
\label{sec:visualization-of-model-predictions}
The interpretation of the model can be understood on two different ways. First we assume for a given training data set, the model is trained and a new test sample is given.
For the given test sample it is possible to visualize the reliability of each used feature in individual classifiers, as well as the overall confidence of each individual classifier. 
Used features can be superimposed onto a PPI network as well as their reliability and the confidence of their respective individual classifier.

\noindent Gene expression and methylation level measurements from cancer samples are usually very noisy. Furthermore, cancers are usually very heterogeneous. Additionally, there might be different subgroups for each interesting group (e.g., cancer stage), for which the importance of the features also differs. To get a global picture of the important features, we therefore evaluate how often certain features are selected by the classifiers using 100 random train test partitionings with 80\% of the data for training and 20\% of the data for testing. 
 To visualize high confidence relationships between features, we create a graph which has a node for every chosen feature in any of the 100 train partitions in any of the individual classifiers. The weight of an edge $(s, t)$ is defined as the number of times the respective features have occurred together in an individual classifier. Then, all edges with low weights are discarded. In order to find a threshold to prune edges according to their weights, a Gaussian kernel density estimate is fit to the weights of the edges, and the threshold is chosen at the 90th percentile. Nodes that have an appearance frequency higher than the threshold are labeled by their gene names and edges having a higher weight than the threshold are kept in the graph.

For illustration purposes, choosing the regularization parameter is done in a way to maximize the number of genes selected with high confidence, as well as minimizing the number of genes pruned out in the process. It is important to remember that considering the results of the method under different regularization parameters is essential to make sure the selected genes possess a high confidence and are also stable regardless of sampling of the training data set.
\subsubsection{Implementation Details}
To compare the performance of our method with other methods, the implementations present in Python \emph{scikit-learn(0.14)} package are taken. In the case of stochastic gradient boosting, the representing class is \emph{GradientBoostingClassifier}, the number of classifiers is set to 100, and to make it sparse and prevent over-fitting, the maximum number of features for splits in trees is set to 5, and the maximum number of layers is set to 2.
For AdaBoost, \emph{AdaBoostClassifier} is used, which is an implementation of AdaBoost-SAMME~\cite{zhu2009multi}, with weak learner set to \emph{DecisionTreeClassifier} with maximum depth set to 2, and the number of weak classifiers set to 100. Parameters of the two boosting algorithms are chosen by a grid search on their parameter space over all the data sets and selecting the parameter sets which give a robust and stable result over all experiments.

As an SVM, $\nu$-SVM with $\nu = 0.25$ is used, once with a linear kernel, and once with an RBF kernel; $\gamma$ parameter of the RBF kernel is set to $\textrm{(num of features)}^{-1}$. The $\nu$ parameter is set to the maximum value for which the optimization function is solvable with \emph{libsvm} for all analyzed data sets~\cite{CC01a}. Smaller values cause the SVM to overfit to the data and not generalize well.
The Gaussian process's correlation function is a squared-exponential, and MIC is estimated using \emph{minepy} package~\cite{albanese2013minerva}.

The PPI network used in our analysis is from the Human Protein Reference Database (HPRD)~\cite{peri2003development}. Almost all edges and relationships between proteins that are added to this database are manually extracted from literature by biologists, hence it has a lower rate of edges included in the database for which there is no evidence in the literature.


\subsection{Results and discussion}
\subsubsection{Interpretability of Predictions}
Here we present the results of running the method on the TCGA-LAML gene expression data set.

\textbf{Visualization of  Features Important for a Particular Test Sample:}
Having a model trained on the data, and given a test sample, it is possible to infer and visualize which individual classifier(s) is (are) influencing the prediction most. To this end, individual learners as well as the features they use are visualized as in Fig.~\ref{fig:sample-model}(a). 
In this figure, nodes with labels starting with ``\emph{L\_}'' represent individual classifiers, and other nodes are labeled with their respective gene name. The color of the node shows its confidence compared to other nodes; the darker the node, the higher the confidence. In the case of a gene, it is the confidence or reliability of the feature ($c_f$), and in the case of an individual classifier, it is the overall estimated confidence ($c_{l_i}$). Edges show which classifier is using which genes in its decision function. The shape of a node represents the individual classifier they belong to.

\begin{figure*}[!tpb]
\setlength{\fboxsep}{0pt}%
\setlength{\fboxrule}{0.5pt}%
  \subfigure[loose][]{\fbox{\includegraphics[width=0.49\textwidth]{figs/rat/figs/testdata-model-TCGA-LAML-GeneExpression-risk_group-4}}}\ \ 
  \subfigure[loose][]{\fbox{\includegraphics[width=0.49\textwidth]{figs/rat/figs/testdata-features-PPI-TCGA-LAML-GeneExpression-risk_group-4}}}
  \caption{\textbf{Visualization of one model} A sample model for TCGA-LAML gene expression data \textbf{(a)} individual classifiers and their selected features; higher confidence of a node is shown by a darker color, \textbf{(b)} selected genes plotted over the PPI network; green and yellow show low and high confidence respectively, and the thickness of the border of the node shows the respective confidence of the individual classifier to which it belongs.}
  \label{fig:sample-model}
\end{figure*}

To get a better overview of the individual features that were chosen by the classifiers for the particular test sample, we visualized the corresponding genes on a graph containing information about the PPI network in Fig.~\ref{fig:sample-model}(b). We extracted the PPI information from HPRD as explained before. This way, it is possible to find over- or under-regulated pathways that might be responsible for the label (e.g., cancer stage) of the test sample. Since PPI networks can be quite dense, we removed parts of the induced network. For this purpose we computed each shortest path between all pairs of selected features. Then, the minimum spanning tree of that section was plotted, after removing branches with no selected feature.

Most of the features chosen by any of the classifiers (colored nodes) are not connected to any other chosen feature. It is known that there is in many cases a correlation between expression value of the genes whose corresponding proteins interact~\cite{jansen2002relating}.
Therefore, a regularized model will only choose a subset of the correlated features. This explains the observation that features selected by a single model can be distant from each other on a PPI network; but if multiple disjoint sparse models are fit to the data, their selected features might happen to be close to each other on the PPI network (e.g., node TPT1 and node EEF1A1 in Fig.~\ref{fig:sample-model}(b)).

It is worth noting that these plots are the result of analyzing one single given test sample. Therefore in practice, these interpretations can be used for each patient and if useful, influence the treatment that the oncologist prescribe for the patient.


\textbf{Visualization of Important Global Features:}
As explained in Section~\ref{sec:visualization-of-model-predictions}, a graph is created from model structures of all 100 random training partitions, and then it is pruned to keep only high confidence nodes and edges.
The density estimation of the graph edge weights and the pruned graph are plotted in Fig.~\ref{fig:summary-network} where the nodes with labels are the ones that are not pruned. The nodes in this figure that do not have any label, are the ones with frequency lower than the corresponding threshold. Among the features considered to be important were features that had previously been linked to leukemia such as SH3KBP1~\cite{Adelaide2010}.

\begin{figure*}[!htpb]
\setlength{\fboxsep}{0pt}%
\setlength{\fboxrule}{0.5pt}%
  \subfigure[loose][]{\fbox{\includegraphics[width=0.49\textwidth]{figs/rat/figs/density-TCGA-LAML-GeneExpression-risk_group-2}}}\ \
  \subfigure[loose][]{\fbox{\includegraphics[width=0.49\textwidth]{figs/rat/figs/summary-TCGA-LAML-GeneExpression-risk_group-02}}}
  \caption{\textbf{(a) Determine pruning threshold} Threshold is determined by finding the point after which, $90\%$ of the area under the curve is observed from left to right. The horizontal axis shows the observed frequency or weight of the edges. \textbf{(b) Important Global Features} High confidence nodes and edges of the graph generated from the model on TCGA-LAML gene expression data. Darker color represents higher rate of being selected by a classifier.}
  \label{fig:summary-network}
\end{figure*}

What was more intriguing to see was that four out of the seven important features of the TCGA-LAML gene expression data set contained ribosomal proteins when using the risk group label, i.e. RPL37A, RPS20, RPS3A, and RPL23A. For a long time ribosomes were just considered machines that perform an unbiased translation of genes from mRNA to amino acid sequences, but this view has recently been challenged~\cite{Xue2012}. One new hypothesis is that the ribosome introduces an additional regulatory layer. Therefore, it could very well be that mutations in ribosomal proteins can lead to a misregulation of expression levels of important genes and ultimately to the development of cancer (in this case leukemia). One of the ribosomal proteins we found was RPL23A. It has been shown that loss of RPL23A can impede growth and lead to morphological abnormalities in Arabidopsis Thaliana~\cite{Xue2012}. Therefore, a mutation in RPL23A might also have severe effects in humans. A missense mutation in RPL23A was recently found in patients having Diamond-Blackfan anemia, which is an inherited form of pure red cell aplasia (related to leukemia)~\cite{Gazda2012}. Note that the model for LAML has low performance for the regularization value chosen. Nevertheless, the features shown here are also the ones with the highest confidence for models learnt with less regularization (with several other additional features). The models with less regularization show similar performance to the other methods shown in Fig.~\ref{fig:performance-summary}

\subsubsection{Performance comparison}
The performance of the method was compared with that of two ensemble methods, AdaBoost and stochastic gradient boosting, as well as an SVM with linear kernel, and an SVM with an RBF kernel. We also included our implementation of the NICK method~\cite{Lavi2012}.
We randomly partitioned the data into training and test sets with $80\%$ of the data for training and $20\%$ of the data for testing. To compare the performance of the different methods, Area Under the receiver operating characteristic Curve (AUC)~\cite{egan1975signal} was calculated on the test set over the decision values returned by the methods on the individual samples. The process was repeated 100 times to reduce random effects.
As seen in Fig.~\ref{fig:performance-summary}, overall performances of all methods are comparable. In some cases a single SVM works better, in some other cases ensemble algorithms give a better performance. However, in most cases an improvement in performance is observed by adding individual learners to the model, with the greatest gains due to the first few individual learners added to the model. 
In two cases, TCGA-LAML/Vital status and TCGA-LAML/Risk Group, our
reported performance measures are significantly lower than other
methods. This, however, comes from the fact that we have enforced
extreme sparsity measures. The performance of the method increases and
reaches the other methods' performance levels if this constraint is
relaxed, as reported in supplementary 1. 
We enforced those sparsity measures for all models to avoid over-fitting. Optimizing the sparsity constraint via cross-validation would have been computationally expensive, which is why we preferred to be conservative. Had we optimized the sparsity constraint, we would have still been able to find the significant features while having similar performance as the other methods.


\begin{landscape}
\begin{figure*}[!th]
\centerline{\includegraphics[angle=270,width=15.7cm]{figs/rat/figs/performance}}
\caption{\textbf{Performance Summary (AUC)} Each box shows a $25$--$75\%$ interval, as well as the median, which is shown as a horizontal line in each box.}\label{fig:performance-summary}
\end{figure*}
\end{landscape}

\subsection{Conclusions}

Machine learning has become more and more popular in many real world scenarios for making sense of large collections of facts. Differences between the data used for training the method and new data for which the label should be predicted can limit the performance of prediction methods on those data. In this work we introduced a method that estimates these potential partial biases and incorporates them into the prediction function. We applied it to gene expression and DNA methylation measurements from cancer patients. Our method has state-of-the-art performance on many different prediction tasks. Furthermore, we show how to make sense of the predictions. Visualizing the important genes can lead to new biological insights, as shown for the TCGA-LAML data set with the risk group label. Instead of mapping the genes to PPI networks, one could also think of mapping them to signaling pathways~\cite{Kanehisa2014}.

Recently, a study showed that most published signatures are not significantly more associated with cancer outcome than random signatures~\cite{Venet2011}. One of the reasons for this finding is that the data comes from slightly different underlying hidden data distributions. Since our new method estimates this bias and corrects for it by up-weighting the classifiers that have higher confidence, we expect that it should be less susceptible to such differences in the data.

In this work we designed and developed a method that besides being a predictive model, it can be used for two different purposes. It can be used as an exploratory method to reveal potential features used in future studies; and it can be used to different underlying causes of the same disease and with its interpretability help oncologists to choose the treatment accordingly.

We would like to point out that the applicability of our method is not limited to cancer outcome prediction, and it can apply to many more scenarios. The method assumes that the data has enough features to select from, and that there are related features to those selected ones that can be used to estimate their reliability. These are conditions that almost all biological data satisfy, hence the method can be applied to them.

The method also works as a skeleton whose components can be easily
substituted. For example, by changing the classifier used in
individual learners to a multi-class classifier, the method would work
on multi-class problems. For the sake of simplicity and without loss
of generality we performed the evaluations only on binary
classification problems. Also, due to the structure of our model, one possible approach would be to use a method such as iRDA and use those gene sets as features of individual learners. Whether this approach leads to better results or not requires further research.
Also, the combination of maximal information coefficient and Gaussian
processes is not the only feasible option, and they can be replaced
with other faster methods if the time complexity of the method is of
any concern. Some of these alternatives are already available on the
\emph{github} repository of the method.


\section{Raccoon}
